#!/usr/bin/perl

###-------------------------------------------------------------------
### File    : catepod.pl
### Author  : whoppix <jwrings@gmail.com>
### Description : Simple daemon construct that does the usual daemon
###         housekeeping, daemonizing, logging, privilege dropping,
###         pid file management, etc...
### License : GPLv2
### Created : 01 Jun 2009 by  <whoppix@localhost.localdomain>
###-------------------------------------------------------------------

use strict;
use warnings;

use POE;
use POE::Wheel::FollowTail;
use Proc::Daemon;

use Catepod::Logger;

use Privileges::Drop;
use JSON;
use Fcntl qw/:flock/;

sub DEBUG() { 0 }

my $configfile = shift @ARGV;
my $conf;

{
    open my $fh, '<', $configfile or die "Couldn't open config file: $!";
    local $/;
    my $content = <$fh>;
    $conf = from_json($content);
    close $fh;
}

my $RUNAS_USER     = $conf->{runas_user};
my $DAEMONIZE      = $conf->{daemonize};
my $NAME           = $conf->{logname};
my $PIDFILE        = $conf->{pidfile};
my $PIPE_DIRECTORY = $conf->{pipe_dir};
my $GSWI_DIR       = $conf->{gswi_dir};
my $GAMES          = $conf->{games};
print "pipe: $PIPE_DIRECTORY\n";

my $VERSION = 0.1;

#
# Workflow:
# - Check if we run as root
# - check PID file
# - Daemonize
# - open log
# - open pipe
# - look up user id to drop privileges to
# - drop privileges
# - process commands
#

die "Must run as root" unless $> == 0;

# Daemonizing
Proc::Daemon::Init() if $DAEMONIZE;

# Open log
our $logger = Catepod::Logger->new($NAME);

open my $lockfile, '>', $PIDFILE
  or $logger->error("Couldn't open $PIDFILE for writing: $!");
flock( $lockfile, LOCK_EX | LOCK_NB )
  or $logger->error("Couldn't lock $PIDFILE, perhaps another instance of $NAME is running already?");

print {$lockfile} $$ . "\n"
  or $logger->error("Couldn't write PID ($$) to $PIDFILE: $!");

# dropping privileges
drop_privileges($RUNAS_USER);

POE::Session->create(
    inline_states => {
        _start   => \&start,
        _stop    => \&stop,
        _default => sub {
            my ( $event, $args ) = @_[ ARG0, ARG1 ];
            $logger->warn("Received unknown signal: $event");
        },
        sig_shutdown      => \&sig_shutdown,
        pipe_data         => \&pipe_data,
        pipe_reset        => \&pipe_reset,
        process_command   => \&process_command,
        pipe_error        => \&pipe_error,
        add_gameserver    => \&add_gameserver,
        delete_gameserver => \&delete_gameserver,
    },
    heap => { gameserver => {}, }
);

POE::Kernel->run();

sub add_gameserver {
    my $port = $_[ARG0];
    my $pid  = $_[ARG1];
    $_[HEAP]->{gameserver}->{$port} = $pid;
}

sub delete_gameserver {
    my $port = $_[ARG0];
    delete $_[HEAP]->{gameserver}->{$port};
}

sub start {
    DEBUG;
    my $user_id = $>;
    $logger->info("version $VERSION Starting as user $user_id");

    #open my $fh, '<', $PIPE_DIRECTORY
    #  or do { my $errstr = "Couldn't open pipe for reading: $!"; $logger->warn($errstr); die($errstr) };
    $_[HEAP]->{fifo} = POE::Wheel::FollowTail->new(
        Filename   => $PIPE_DIRECTORY,
        InputEvent => "pipe_data",
        ResetEvent => "pipe_reset",
        ErrorEvent => "pipe_error",
      )
      or $logger->warn("Couldn't spawn wheel: $!");
    POE::Kernel->sig( INT => "sig_shutdown" );
    POE::Kernel->alias_set('catepod');
}

sub stop {
    DEBUG;
    POE::Kernel->alias_remove('catepod');
    $logger->info("Stopping.");
    flock( $lockfile, LOCK_UN )
      or $logger->warn("Failed to unlock $PIDFILE: $!");
}

sub pipe_data {
    DEBUG;
    my $input = $_[ARG0];
    my $hashref;
    eval { $hashref = from_json($input); };
    if ($@) {
        $logger->warn("received invalid JSON: $input");
        return;
    }
    POE::Kernel->yield( 'process_command', $hashref );
}

sub pipe_reset {    # we don't do anything here, pipes can't be reset.
    DEBUG;
}

sub pipe_error {
    DEBUG;
    my ( $operation, $errnum, $errstr, $id ) = @_[ ARG0 .. ARG3 ];
    $logger->info("pipe error while $operation: $errnum, $errstr, $id");
}

sub sig_shutdown {
    DEBUG;
    $logger->warn("received shutdown signal, exiting.");
    delete $_[HEAP]->{fifo};    # freeing the resource we are watching
    foreach my $key ( keys %{ $_[HEAP]->{gameserver} } ) {
        POE::Kernel->post( $key => "shutdown" );
    }
    $_[KERNEL]->sig_handled();
}

sub process_command {
    DEBUG;
    my $data = $_[ARG0];
    if ( !$data->{command} ) {
        $logger->warn("invalid json sent: command is missing");
        return;
    }
    if ( $data->{command} eq 'quit' ) {
        $logger->warn("received quit command, exiting...");
        delete $_[HEAP]->{fifo};
        POE::Kernel->yield('sig_shutdown');
    }
    elsif ( $data->{command} eq 'start' ) {
        my $port       = $data->{port};
        my $game       = $data->{game};
        my $params_ref = $data->{params};
        my $install    = $data->{install};
        my $poco;
        my $gsdir = $data->{path};

        unless ( $port >= 1024 && $port <= 65535 ) {
            $logger->warn("server port: '$port' is to low, or to high.");
            return;
        }
        unless ( $poco = $conf->{games}->{$game} ) {
            $logger->warn(
                "Do not know what to do with game '$game', perhaps you forgot to specify a poco for it in the config?"
            );
            return;
        }
        if ( @$params_ref <= 0 ) {
            $logger->warn("cannot start gameserver '$port'  without params.");
            return;
        }
        $logger->info( "Starting $poco with params: '"
              . $params_ref
              . "' in: '$gsdir', "
              . ( $install ? "while installing it" : "" ) );

        # starting the gameserver
        my $require_name = $poco;
        $require_name =~ s/::/\//g;
        $require_name .= '.pm';
        eval { require $require_name; };
        if ($@) { $logger->info("Error while compilling $poco: $@"); return; }
        eval { $poco->create( path => $gsdir, params => $params_ref, ( $install ? ( install => 1 ) : () ) ); };

        if ($@) {
            $logger->info("Error while starting $poco: $@");
            return;
        }
    }
    elsif ( $data->{command} eq "stop" ) {
        my $path = $data->{path};
        $logger->warn($path);
        $_[KERNEL]->post( $path => '_shutdown' );
        $logger->info("stop gameserver in: $path");
    }
    else {
        $logger->warn( "invalid json sent: couldn' t understand command '" . $data->{command} . "'" );
    }
}

