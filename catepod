#/usr/bin/perl

### insert header & licensing conditions here

use strict;
use warnings;

use POE;
use POE::Wheel::FollowTail;
use Proc::Daemon;

use Catepod::Logger;
use Catepod::GsLogger;

use Privileges::Drop;
use JSON;
use Fcntl qw/:flock/;

my $configfile = shift @ARGV;
my $conf;

{
    open my $fh, '<', $configfile or die "Couldn't open config file: $!";
    local $/;
    my $content = <$fh>;
    $conf = from_json($content);
    close $fh;
}

my $RUNAS_USER     = $conf->{runas_user};
my $DAEMONIZE      = $conf->{daemonize};
my $NAME           = $conf->{logname};
my $PIDFILE        = $conf->{pidfile};
my $PIPE_DIRECTORY = $conf->{pipe_dir};
my $GSWI_DIR       = $conf->{gswi_dir};
my $GAMES          = $conf->{games};
my $PACKAGE_DIR    = $conf->{packagedir};

my $VERSION = 0.1;

#
# Workflow:
# - Check if we run as root
# - check PID file
# - Daemonize
# - open log
# - open pipe
# - look up user id to drop privileges to
# - drop privileges
# - process commands
#

die "Must run as root" unless $> == 0;

# Daemonizing
Proc::Daemon::Init() if $DAEMONIZE;

# Open log
our $logger   = Catepod::Logger->new($NAME);
our $gslogger = Catepod::GsLogger->new($NAME);

sub DEBUG() {
    eval {
        my $debuggmsg = ( caller 2 )[3];
        $logger->info("DEBUG: $debuggmsg");
    };
}

open my $lockfile, '>', $PIDFILE
  or $logger->error("Couldn't open $PIDFILE for writing: $!");
flock( $lockfile, LOCK_EX | LOCK_NB )
  or $logger->error("Couldn't lock $PIDFILE, perhaps another instance of $NAME is running already?");

print {$lockfile} $$ . "\n"
  or $logger->error("Couldn't write PID ($$) to $PIDFILE: $!");

# dropping the privileges
#drop_privileges($RUNAS_USER);

POE::Session->create(
    inline_states => {
        _start   => \&start,
        _stop    => \&stop,
        _default => sub {
            my ( $event, $args ) = @_[ ARG0, ARG1 ];
            $logger->warn("Received unknown signal: $event");
        },
        sig_shutdown      => \&sig_shutdown,
        pipe_data         => \&pipe_data,
        pipe_reset        => \&pipe_reset,
        process_command   => \&process_command,
        pipe_error        => \&pipe_error,
        add_gameserver    => \&add_gameserver,
        delete_gameserver => \&delete_gameserver,
    },
    heap => { gameserver => {}, }
);

POE::Kernel->run();

sub add_gameserver {
    DEBUG;
    my $port = $_[ARG0];
    my $pid  = $_[ARG1];
    $_[HEAP]->{gameserver}->{$port} = $pid;
}

sub delete_gameserver {
    DEBUG;
    my $port = $_[ARG0];
    delete $_[HEAP]->{gameserver}->{$port};
}

sub start {
    DEBUG;
    my $user_id = $>;
    $logger->info("version $VERSION Starting as user $user_id");

    #open my $fh, '<', $PIPE_DIRECTORY
    #  or do { my $errstr = "Couldn't open pipe for reading: $!"; $logger->warn($errstr); die($errstr) };
    $_[HEAP]->{fifo} = POE::Wheel::FollowTail->new(
        Filename   => $PIPE_DIRECTORY,
        InputEvent => "pipe_data",
        ResetEvent => "pipe_reset",
        ErrorEvent => "pipe_error",
    ) or $logger->warn("Couldn't spawn wheel: $!");
    POE::Kernel->sig( INT => "sig_shutdown" );
    POE::Kernel->alias_set('catepod');
}

sub stop {
    DEBUG;
    POE::Kernel->alias_remove('catepod');
    $logger->info("Stopping.");
    flock( $lockfile, LOCK_UN )
      or $logger->warn("Failed to unlock $PIDFILE: $!");
}

sub pipe_data {
    DEBUG;
    my $input = $_[ARG0];
    my $hashref;
    eval { $hashref = from_json($input); };
    if ($@) {
        $logger->warn("received invalid JSON: $input");
        return;
    }
    POE::Kernel->yield( 'process_command', $hashref );
}

sub pipe_reset {    # we don't do anything here, pipes can't be reset.
    DEBUG;
}

sub pipe_error {
    DEBUG;
    my ( $operation, $errnum, $errstr, $id ) = @_[ ARG0 .. ARG3 ];
    $logger->info("pipe error while $operation: $errnum, $errstr, $id");
}

sub sig_shutdown {
    DEBUG;
    $logger->warn("received shutdown signal, exiting.");
    delete $_[HEAP]->{fifo};    # freeing the resource we are watching
    foreach my $key ( keys %{ $_[HEAP]->{gameserver} } ) {
        POE::Kernel->post( $key => "shutdown" );
    }
    $_[KERNEL]->sig_handled();
}

sub process_command {
    DEBUG;
    my $data = $_[ARG0];
    if ( !$data->{command} ) {
        $logger->warn("invalid json sent: command is missing");
        return;
    }
    if ( $data->{command} eq 'quit' ) {
        $logger->warn("received quit command, exiting...");
        delete $_[HEAP]->{fifo};
        POE::Kernel->yield('sig_shutdown');
    }
    elsif ( $data->{command} eq 'start' ) {
        my $port       = $data->{port};
        my $game       = $data->{game};
        my $params_ref = $data->{params};
        my $install    = $data->{install};
        my $poco;
        my $gsdir = $data->{path};

        unless ( $port >= 1024 && $port <= 65535 ) {
            $logger->warn("server port: '$port' is to low, or to high.");
            return;
        }
        unless ( $poco = $conf->{games}->{$game} ) {
            $logger->warn(
                "Do not know what to do with game '$game', perhaps you forgot to specify a poco for it in the config?"
            );
            return;
        }
        unless ( @$params_ref > 0 ) {
            $logger->warn("cannot start gameserver '$port'  without params.");
            return;
        }

        my $ins;
        if    ( $install eq "install" )   { $ins = ", while install it"; }
        elsif ( $install eq "reinstall" ) { $ins = ", while reinstalling it"; }

        $logger->info( "Starting $poco with params: '" . "@$params_ref" . "' in: '$gsdir'" . $ins . "." );

        # starting the gameserver
        my $require_name = $poco;
        $require_name =~ s/::/\//g;
        $require_name .= '.pm';
        eval { require $require_name; };
        if ($@) { $logger->info("Error while compilling $poco: $@"); return; }
        eval {
            $poco->create(
                path     => $gsdir,
                params   => $params_ref,
                install  => $install,
                packages => $PACKAGE_DIR,
                port     => $port
            );
        };

        if ($@) {
            $logger->info("Error while starting $poco: $@");
            return;
        }
    }
    elsif ( $data->{command} eq "stop" ) {
        my $path = $data->{path};
        my $gsID = $data->{gsID};

        if ( $data->{install} eq "remove" ) {
            if ( !$_[KERNEL]->post( $path => 'remove' ) ) {
                if ( $! eq "No such process" ) {
                    $gslogger->warn( "The server doesn't run, but it have to be for removing, aborting deinstallation.",
                        $gsID );
                    $logger->info("The server have to been running before we can remove it.");
                }
                else {
                    $logger->warn("Error while post remove in $path: $!");
                    return;
                }
            }
        }

        $logger->info( "Attempting to stop Gameserver in: " . $path );

        if ($!) { $logger->info("$!"); }
        if ( !$_[KERNEL]->post( $path => '_stop_gameserver' ) ) {
            $logger->warn("Error while posting '_stop_gameserver' to $path: $!");
            return;
        }

    }
    elsif ( $data->{command} eq "restart" ) {
        my $path = $data->{path};
        my $port = $data->{port};
        $logger->info( "Attempting to restart Gameserver in: " . $path );

        if ( !$_[KERNEL]->post( $path => 'stop' ) ) {
            $logger->warn("Couldn't stop Server in $path, maybe there does not run a server ?: $!");
            return;
        }

        if ( !$_[KERNEL]->post( $path => '_start_gameserver' ) ) {
            $logger->warn("Couldn't start Server in $path: $!");
            return;
        }
    }
    elsif ( $data->{command} eq "reinstall" ) {
        my $path = $data->{path};

        $logger->info("Start reinstallation of Gameserver in $path.");

        if ( !$_[KERNEL]->post( $path => '_reinstall' ) ) {
            $logger->warn("Coudln't send reinstall signal to gameserver in $path, maybe there doesn't run one ?: $!");
            return;
        }

    }
    elsif ( $data->{command} eq "install_mod" ) {
        my $path        = $data->{path};
        my $mod         = $data->{mod};
        my $install     = $data->{install};
        my $PACKAGE_DIR = $conf->{packagedir} . "/Addons/";
        my $poco;

        if ( !-e "$PACKAGE_DIR" ) {
            $logger->warn("Addons directory '$PACKAGE_DIR' does not exists");
            return;
        }

        if ( !-e "$path" ) {
            $logger->warn("There isnt installed a gameserver in $path !");
            return;
        }

        unless ( $poco = $conf->{mods}->{$mod} ) {
            $logger->warn("Do not know what todo with $mod, perhabs you forgot to specify a poco for $mod ?");
            return;
        }

        my $require_name = $poco;
        $require_name =~ s/::/\//g;
        $require_name .= '.pm';
        eval { require $require_name; };
        if ($@) { $logger->info("Error while compilling $poco: $@"); return; }
        eval { $poco->create( path => $path, install => $install, mod => $mod, package_dir => $PACKAGE_DIR ); };

        if ($@) {
            $logger->info("Error while starting $poco: $@");
            return;
        }

    }
    elsif ( $data->{command} eq "install_map" ) {
        my $mapname   = $data->{mapname};
        my $port      = $data->{port};
        my $path      = "$GSWI_DIR/gameserver/$port";
        my $FD_SERVER = $data->{fastdownloadserver};
        my $FD_LINK   = $data->{fastdownloadlink};
        my $DL_LINK   = "$FD_SERVER/$FD_LINK";

        if ( !-e "$path" ) {
            $logger->warn("It seems, that in $path isn't installed a gameserver, aborting.");
            return;
        }

        if ( $mapname !~ m/.*bsp/ ) {
            if ( !chdir($path) ) {
                $logger->warn("Couldn't chdir to $path: $!");
                return;
            }

            system(" wget $DL_LINK ");

            $logger->warn("Installed $mapname successful to server in $path.");
        }
        else {
            $logger->warn("$mapname isn't a regular mapfile name or format, aborting.");
            return;
        }

    }
    elsif ( $data->{command} eq "process_command" ) {
        my $cmd  = $data->{cmd};
        my $path = $data->{path};

        if ( !$_[KERNEL]->post( $path => '_process_command', "command" => $cmd ) ) {
            $logger->warn("Error while processing command $cmd to $path");
            return;
        }
    }
    else {
        $logger->warn( "invalid json sent: couldn't understand command '" . $data->{command} . "'" );
    }
}

